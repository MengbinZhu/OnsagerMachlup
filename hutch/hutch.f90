!adjoint with Hutchinson estimator
module     param
  !******************************************************************
  !******************************************************************
  !** This routine was generated by Automatic differentiation.     **
  !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
  !******************************************************************
  !******************************************************************
  implicit none

  !==============================================
  ! declare parameters
  !==============================================
  integer(kind=4), parameter :: ii = 3
  integer, parameter :: ikind2 = 8
  integer(kind=4), parameter :: nobs = 1
  integer(kind=4), parameter :: nt = 1600
!  integer(kind=4), parameter :: nt = 16000
!  integer(kind=4), parameter :: nt = 32000
  integer(kind=4), parameter :: ntd = 1

  !==============================================
  ! declare local variables
  !==============================================
  real(kind=8) :: a = 0.2
  real(kind=8) :: b = 0.2
  real(kind=8) :: c = 6
  real(kind=8) :: fn(ii,0:nt)=0
  real(kind=8) :: fn_ad(ii,0:nt)=0
  real(kind=8) :: fn_tl(ii,0:nt)=0
  real(kind=8) :: h = 5.0D-4
  real(kind=8) :: sigb = 0.2
  real(kind=8) :: sigm = 2
#ifdef CHECK
  real(kind=8) :: sigm_tmp = 0.0d0
  integer(kind=4) :: ic
#endif
  real(kind=8) :: sigo = 0.2
  real(kind=8) :: xb(ii)

contains
  subroutine param_constructor_ad
    !******************************************************************
    !******************************************************************
    !** This routine was generated by Automatic differentiation.     **
    !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
    !******************************************************************
    !******************************************************************
    implicit none

    !----------------------------------------------
    ! RESET ADJOINT MODULE VARIABLES
    !----------------------------------------------
    fn_ad(:,:) = 0._ikind2

  end subroutine param_constructor_ad
end module     param

module obsdata
  use param
  implicit none
  real(8) :: xobs(ii,nobs)
  real(8) :: xo(ii,0:nt)
  real(8) :: tobs(nobs), t
  real(8) :: x_fg(ii,0:nt)
#ifdef ANOTHER_FG
  real(8) :: x_fg2(ii,0:nt)
#endif
contains
  subroutine setobs
    implicit none
    real(8) :: dw(ii*nt)
    real(8) :: dw2(ii)
    integer(4) :: i, it, iobs

    tobs(1) = 0.4
    !obs data almost on the attractor
    xb(1)= 2.0659834; xb(2)=-0.2977757; xb(3)= 2.0526298

    call func_dw(h,dw2,ii)  
    do i=1,ii
       x_fg(i,0) = xb(i) + sigb*dw2(i) 
    enddo
!    x_fg(1,1) = -5.90851E+00; x_fg(2,1) = -1.91864E+00; x_fg(3,1) =  -1.11507E-02  
    call func_dw(h,dw,ii*nt)  
    do it=0,nt-1
       call func_ross( x_fg(:,it),fn(:,it) )
       do i=1,ii
          x_fg(i,it+1) = x_fg(i,it) + fn(i,it)*h + sigm*dw(i+it*ii)
       enddo
    enddo !firstguess

    xo(:,:) = -999
    do it=0,nt
       do iobs = 1,nobs
          if(tobs(iobs)-it*h>-h/2 .and. tobs(iobs)-it*h<=h/2) then
             call func_dw(1.0d0,dw2,ii)  
             do i=1,ii
                xo(i,it) = x_fg(i,it) + sigo*dw2(i)
                xobs(i,iobs) = xo(i,it) 
             enddo
          endif
       enddo
#ifndef ANOTHER_FG
       write(11,'(a,10(1x,f14.7))') "x",it*h,x_fg(:,it),xo(:,it)
#endif
    enddo
#ifdef ANOTHER_FG
    call func_dw(h,dw2,ii)  
    do i=1,ii
       x_fg2(i,1) = xb(i) + sigb*dw2(i) 
    enddo
    call func_dw(h,dw,ii*nt)  
    do it=0,nt-1
       if(mod(it,100)==0) then
          call func_dw(h,dw2,ii)  
          do i=1,ii
#ifndef NOISELESS
             x_fg2(i,it) = x_fg(i,it) + sigm*dw2(i) 
#endif
          enddo
       endif
       call func_ross( x_fg2(:,it),fn(:,it) )
       do i=1,ii
#ifndef NOISELESS
          x_fg2(i,it+1) = x_fg2(i,it) + fn(i,it)*h + sigm*dw(i+it*ii)
#else
          x_fg2(i,it+1) = x_fg2(i,it) + fn(i,it)*h !+ sigm*dw(i+it*ii)
#endif
       enddo
    enddo !firstguess
    do it=0,nt
       write(11,'(a,10(1x,f14.7))') "x",it*h,x_fg2(:,it),xo(:,it)
    enddo
#endif
  end subroutine setobs
end module obsdata

program    main
  !******************************************************************
  !******************************************************************
  !** This routine was generated by Automatic differentiation.     **
  !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
  !******************************************************************
  !******************************************************************
  !==============================================
  ! referencing used modules
  !==============================================
  use mpi
  use param
  use obsdata
  use mtmod
  implicit none

  !==============================================
  ! declare local variables
  !==============================================
  real(kind=8) :: x(ii,0:nt)
  real(kind=8) :: xold(ii,0:nt)
!  real(kind=8) :: xx(ii,0:nt)
  real(kind=8) :: adx(ii,0:nt)
!  real(8) :: adxx(ii,0:nt)=0
  integer(kind=4) :: it, itr
  integer(kind=4) :: ntr  = 10000000
  integer(kind=4) :: itr0 = 1000000
!  real(8) :: q0, q1, logr, ratio
!  real(8) ::  r=5d-3
  real(8) :: S=2.0d20
  real(8), parameter :: alp=1.d-2
  real(8) :: Sold, alp1, norm, tol=1d-7, norm_sum=0.0d0
!  real(8) :: Sold, alp1, norm, tol=1d-4
  integer(4) :: acc(0:1)=0
  integer(4) :: acc_all(0:1)=0
  real(8) :: dw(ii*nt)
  real(8) :: mean(ii,0:nt)=0.0  
  real(8) :: vari(ii,0:nt)=0.0  
  real(8) :: mean_all(ii,0:nt)=0.0  
  real(8) :: vari_all(ii,0:nt)=0.0  
  real(8) :: Z=0.0  
  real(8) :: Z_all=0.0  , dum
  integer(4) :: err, rank, size
#if 0
  integer(4), parameter :: mm=120
  real(8), parameter :: xmin=-1, xmax=2.5
  real(8) :: dx=(xmax-xmin)/mm
  real(8) :: dens(ntd,mm,mm)=0.0
  real(8) :: dens_all(ntd,mm,mm)=0.0
#endif
  integer(4) :: mx, my, i
  real(kind=8) zeta(ii,0:nt)

  call sgrnd(1)

#ifdef READ_OBS
  tobs(1) = 0.4
  xb(1)= 2.0659834; xb(2)=-0.2977757; xb(3)= 2.0526298
  open(11,file="../ref/fort.11")
  do it=0,nt/2
     read(11,'(1x,10(1x,f14.7))') dum,x_fg(:,it),xo(:,it)
!     if(rank.eq.0)write(0,'(1x,10(1x,f14.7))') dum,x_fg(:,it),xo(:,it)
  enddo
  close(11)
  xobs(:,1) = xo(:,nt/2) 
#else
  call setobs
#endif

#ifdef READ_FG
  open(11,file="../eul000/fort.13")
  do it=0,nt
     read(11,'(3x,20(1x,e12.5))')  dum, x_fg2(:,it)
  enddo
  close(11)
#endif

#ifdef ANOTHER_FG
  x(:,:) = x_fg2(:,:)
#else  x(:,:) = x_fg(:,:)
#endif
#ifdef CHECK
  em_loop: do ic = 1,3
#endif
  call func_dwh(zeta,ii*(nt+1))
  call fwd2( x,zeta,S )
  write(*,'(2i8,5(1x,1pe10.3))') itr, i, S, norm, x(:,nt)
  ens_loop: do itr=1,ntr
     !adj
     call fwd2_ad( x,zeta, adx, S, 1.0d0 )
     !line search
     Sold = S
     alp1 = alp
     xold(:,:) = x(:,:)
     do i=1,100
        x(:,:)=xold(:,:)-alp1*adx(:,:)
        call func_dwh(zeta,ii*(nt+1))
        call fwd2( x,zeta,S )
        if(S>Sold) then
           alp1 = alp1*0.5
        else
           exit
        endif
     enddo
!        write(0,*) itr, i, S
     norm=sum(adx(:,:)**2)
     norm_sum=norm_sum+norm
     if(mod(itr,10000)==0)write(*,'(2i8,6(1x,1pe10.3))') itr, i, S, norm, x(:,nt), norm_sum/itr
     if(norm<tol) then
        write(*,'(2i8,5(1x,1pe10.3))') itr, i, S, norm, x(:,nt)
        exit
     endif
!     if(norm<tol .or. abs(S-Sold)<1.d-12) exit
  enddo ens_loop
#ifdef CHECK
  if(ic==1) then
#endif
  open(12,file="fort.12")
  do it=0,nt
     write(12,'(a3,20(1x,1pe12.5))') "Out", it*h, x(:,it)
  enddo
  close(12)
#ifdef CHECK
  endif
#endif

#ifdef CHECK
!consitency check
   do it = 0, nt-1
      call func_ross( x(:,it),fn(:,it) )
      do i = 1, ii
         sigm_tmp = sigm_tmp+((x(i,it+1)-x(i,it))/h-fn(i,it))**2*h
      enddo
   enddo
   sigm_tmp = sqrt(sigm_tmp/(nt*h*ii))
   write(*,'(2i8,7(1x,1pe10.3))') itr, i, S, norm, x(:,nt), sigm_tmp, sigm
   sigm = sigm_tmp
   enddo em_loop
  open(13,file="fort.13")
  do it=0,nt
     write(13,'(a3,20(1x,1pe12.5))') "Out", it*h, x(:,it)
  enddo
  close(13)
#endif

end program    main

subroutine fwd( x, S )
  !******************************************************************
  !******************************************************************
  !** This routine was generated by Automatic differentiation.     **
  !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
  !******************************************************************
  !******************************************************************
  !==============================================
  ! referencing used modules
  !==============================================
  use param
  use obsdata
  implicit none

  !==============================================
  ! declare arguments
  !==============================================
  real(kind=8), intent(out) :: S
  real(kind=8), intent(in) :: x(ii,0:nt)

  !==============================================
  ! declare local variables
  !==============================================
  integer(kind=4) :: i
  integer(kind=4) :: iobs
  integer(kind=4) :: it

  S = 0.0
  do i = 1, ii
     S = S+(x(i,0)-xb(i))**2/sigb**2/2
  end do
  !write(0,*) "S =", S
  do it = 0, nt-1
     call func_ross( x(:,it),fn(:,it) )
     do i = 1, ii
        S = S+((x(i,it+1)-x(i,it))/h-fn(i,it))**2/sigm**2/2*h
     end do
     S = S + (x(1,it)+a-c)/2*h
  enddo
  do it = 0, nt
     do iobs = 1, nobs
          if(tobs(iobs)-it*h>-h/2 .and. tobs(iobs)-it*h<=h/2) then
           do i = 1, ii
              S = S+(x(i,it)-xobs(i,iobs))**2/sigo**2/2
           end do
        endif
     end do
  end do
  !write(0,*) "S =",S

end subroutine fwd

subroutine fwd_ad( x, x_ad, S, S_ad )
  !******************************************************************
  !******************************************************************
  !** This routine was generated by Automatic differentiation.     **
  !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
  !******************************************************************
  !******************************************************************
  !==============================================
  ! referencing used modules
  !==============================================
  use param
  use obsdata 

  implicit none

  !==============================================
  ! declare arguments
  !==============================================
  real(kind=8), intent(in) :: S
  real(kind=8), intent(in) :: S_ad
  real(kind=8), intent(in) :: x(ii,0:nt)
  real(kind=8), intent(inout) :: x_ad(ii,0:nt)

  !==============================================
  ! declare local variables
  !==============================================
  integer(kind=4) :: i
  integer(kind=4) :: iobs
  integer(kind=4) :: it

  !----------------------------------------------
  ! RESET GLOBAL ADJOINT VARIABLES
  !----------------------------------------------
  call zero_ad
  x_ad(:,:)=0.0
  do it = nt, 0, -1
     do iobs = 1, nobs
          if(tobs(iobs)-it*h>-h/2 .and. tobs(iobs)-it*h<=h/2) then
!        if (abs(tobs(iobs)-it*h) .lt. h/2) then
           do i = 1, ii
              x_ad(i,it) = x_ad(i,it)+S_ad*(2*(x(i,it)-xobs(i,iobs))/sigo**2/float(2))
           end do
        endif
     end do
  enddo
  do it = nt-1, 0, -1
     call func_ross( x(:,it),fn(:,it) )
     x_ad(1,it) = x_ad(1,it) + S_ad/2*h
     do i = 1, ii
        fn_ad(i,it) = fn_ad(i,it)+S_ad*((-2)*((x(i,it+1)-x(i,it))/h-fn(i,it))/sigm**2/float(2))*h
        x_ad(i,it+1) = x_ad(i,it+1)+S_ad*(2*(1/h)*((x(i,it+1)-x(i,it))/h-fn(i,it))/sigm**2/float(2))*h
        x_ad(i,it) = x_ad(i,it)+S_ad*(2*((-1)/h)*((x(i,it+1)-x(i,it))/h-fn(i,it))/sigm**2/float(2))*h
     end do
     call func_ross_ad( x(:,it),x_ad(:,it),fn_ad(:,it) )
  end do
  do i = 1, ii
     x_ad(i,0) = x_ad(i,0)+S_ad*(2*(x(i,0)-xb(i))/sigb**2/float(2))
  end do

end subroutine fwd_ad


subroutine fwd2( x, z, S )
  !******************************************************************
  !******************************************************************
  !** This routine was generated by Automatic differentiation.     **
  !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
  !******************************************************************
  !******************************************************************
  !==============================================
  ! referencing used modules
  !==============================================
  use param
  use obsdata
  use mtmod
  implicit none

  !==============================================
  ! declare arguments
  !==============================================
  real(kind=8), intent(out) :: S
  real(kind=8), intent(in) :: x(ii,0:nt), z(ii,0:nt)
  real(kind=8) :: fp(ii,0:nt)
  real(kind=8) :: bk=1.0d-5

  !==============================================
  ! declare local variables
  !=============================================
  integer(kind=4) :: i
  integer(kind=4) :: iobs
  integer(kind=4) :: it

  S = 0.0
  do i = 1, ii
     S = S+(x(i,0)-xb(i))**2/sigb**2/2
  end do
  !write(0,*) "S =", S
  do it = 0, nt-1
     call func_ross( x(:,it),fn(:,it) )
     do i = 1, ii
        S = S+((x(i,it+1)-x(i,it))/h-fn(i,it))**2/sigm**2/2.0d0*h
     end do
     call func_ross( x(:,it)+bk*z(:,it),fp(:,it) )
     do i = 1, ii
        S = S + z(i,it)*(fp(i,it)-fn(i,it))*h/(2.0d0*bk)
     enddo
  enddo
  do it = 0, nt
     do iobs = 1, nobs
          if(tobs(iobs)-it*h>-h/2 .and. tobs(iobs)-it*h<=h/2) then
           do i = 1, ii
              S = S+(x(i,it)-xobs(i,iobs))**2/sigo**2/2
           end do
        endif
     end do
  end do
  !write(0,*) "S =",S

end subroutine fwd2

subroutine fwd2_ad( x, z, x_ad, S, S_ad )
  !******************************************************************
  !******************************************************************
  !** This routine was generated by Automatic differentiation.     **
  !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
  !******************************************************************
  !******************************************************************
  !==============================================
  ! referencing used modules
  !==============================================
  use param
  use obsdata 

  implicit none

  !==============================================
  ! declare arguments
  !==============================================
  real(kind=8), intent(in) :: S
  real(kind=8), intent(in) :: S_ad
  real(kind=8), intent(in) :: x(ii,0:nt), z(ii,0:nt)
  real(kind=8), intent(inout) :: x_ad(ii,0:nt)
  real(kind=8) :: fp_ad(ii,0:nt)
  real(kind=8) :: bk=1.0d-5

  !==============================================
  ! declare local variables
  !==============================================
  integer(kind=4) :: i
  integer(kind=4) :: iobs
  integer(kind=4) :: it

  !----------------------------------------------
  ! RESET GLOBAL ADJOINT VARIABLES
  !----------------------------------------------
  call zero_ad
  x_ad(:,:)=0.0
  do it = nt, 0, -1
     do iobs = 1, nobs
          if(tobs(iobs)-it*h>-h/2 .and. tobs(iobs)-it*h<=h/2) then
!        if (abs(tobs(iobs)-it*h) .lt. h/2) then
           do i = 1, ii
              x_ad(i,it) = x_ad(i,it)+S_ad*(2*(x(i,it)-xobs(i,iobs))/sigo**2/float(2))
           end do
        endif
     end do
  enddo
  do it = nt-1, 0, -1
     do i=1,ii
        fp_ad(i,it) = fp_ad(i,it) + S_ad*z(i,it)*h/(2.0d0*bk)
        fn_ad(i,it) = fn_ad(i,it) - S_ad*z(i,it)*h/(2.0d0*bk)
     enddo
     call func_ross_ad( x(:,it)+bk*z(:,it),x_ad(:,it),fp_ad(:,it) )
     do i = 1, ii
        fn_ad(i,it) = fn_ad(i,it)+S_ad*((-2)*((x(i,it+1)-x(i,it))/h-fn(i,it))/sigm**2/float(2))*h
        x_ad(i,it+1) = x_ad(i,it+1)+S_ad*(2*(1/h)*((x(i,it+1)-x(i,it))/h-fn(i,it))/sigm**2/float(2))*h
        x_ad(i,it) = x_ad(i,it)+S_ad*(2*((-1)/h)*((x(i,it+1)-x(i,it))/h-fn(i,it))/sigm**2/float(2))*h
     end do
     call func_ross_ad( x(:,it),x_ad(:,it),fn_ad(:,it) )
  end do
  do i = 1, ii
     x_ad(i,0) = x_ad(i,0)+S_ad*(2*(x(i,0)-xb(i))/sigb**2/float(2))
  end do

end subroutine fwd2_ad

subroutine func_ross( x, f )
  !******************************************************************
  !******************************************************************
  !** This routine was generated by Automatic differentiation.     **
  !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
  !******************************************************************
  !******************************************************************
  !==============================================
  ! referencing used modules
  !==============================================
  use param

  implicit none

  !==============================================
  ! declare arguments
  !==============================================
  real(kind=8), intent(out) :: f(ii)
  real(kind=8), intent(in) :: x(ii)

  f(1) = (-x(2))-x(3)
  f(2) = x(1)+a*x(2)
  f(3) = b+x(1)*x(3)-c*x(3)
end subroutine func_ross

subroutine func_ross_ad( x, x_ad, f_ad )
  !******************************************************************
  !******************************************************************
  !** This routine was generated by Automatic differentiation.     **
  !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
  !******************************************************************
  !******************************************************************
  !==============================================
  ! referencing used modules
  !==============================================
  use param

  implicit none

  !==============================================
  ! declare parameters
  !==============================================
  integer, parameter :: ikind1 = 8
  integer, parameter :: ikind3 = 8
  integer, parameter :: ikind4 = 8

  !==============================================
  ! declare arguments
  !==============================================
  real(kind=8), intent(inout) :: f_ad(ii)
  real(kind=8), intent(in) :: x(ii)
  real(kind=8), intent(inout) :: x_ad(ii)

  x_ad(3) = x_ad(3)+f_ad(3)*(x(1)-c)
  x_ad(1) = x_ad(1)+f_ad(3)*x(3)
  f_ad(3) = 0._ikind1
  x_ad(2) = x_ad(2)+f_ad(2)*a
  x_ad(1) = x_ad(1)+f_ad(2)
  f_ad(2) = 0._ikind3
  x_ad(3) = x_ad(3)-f_ad(1)
  x_ad(2) = x_ad(2)-f_ad(1)
  f_ad(1) = 0._ikind4

end subroutine func_ross_ad


subroutine func_dw(h,dw,mm)  
  use mtmod
  implicit none
  integer(4), intent(in) :: mm
  real(8), intent(in)  :: h
  real(8), intent(out) :: dw(mm) 
  real(8) :: x, y, z
  integer(4) :: i
  do i=1,mm/2
     DO
        x = 2.0 * grnd() - 1.0
        y = 2.0 * grnd() - 1.0
        z = x*x + y*y
        if( z <= 1.0 ) exit
     END DO
     dw(2*i-1) = sqrt(h)*x*sqrt(-2.0d0*log(z)/z)
     dw(2*i  ) = sqrt(h)*y*sqrt(-2.0d0*log(z)/z)
  enddo
  if (mod(mm,2)==1) then
     DO
        x = 2.0 * grnd() - 1.0
        y = 2.0 * grnd() - 1.0
        z = x*x + y*y
        if( z <= 1.0 ) exit
     END DO
     dw(mm) = sqrt(h)*x*sqrt(-2.0d0*log(z)/z)
  endif
end subroutine func_dw

subroutine func_dwh(dw,mm)  
  use mtmod
! Rademacher 
  implicit none
  integer(4), intent(in) :: mm
  real(8), intent(out) :: dw(mm) 
  integer(4) :: i
  do i=1,mm
     dw(i) = dsign(1.0d0,grnd()-0.5d0)
  enddo
end subroutine func_dwh

subroutine zero_ad
  !******************************************************************
  !******************************************************************
  !** This routine was generated by Automatic differentiation.     **
  !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
  !******************************************************************
  !******************************************************************
  !==============================================
  ! referencing used modules
  !==============================================
  use param

  implicit none


  !----------------------------------------------
  ! reset adjoint module variables
  !----------------------------------------------
  call param_constructor_ad

end subroutine zero_ad
