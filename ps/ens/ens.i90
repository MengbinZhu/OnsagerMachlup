# 1 "../ens.f90"
module     param
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare parameters
!==============================================
  integer(kind=4), parameter :: ii = 3
  integer, parameter :: ikind2 = 8
  integer(kind=4), parameter :: nobs = 1
!#ifdef 1
!  integer(kind=4), parameter :: nt2 = 1600
!#endif
  integer(kind=4), parameter :: nt = 800
!  integer(kind=4), parameter :: nt = 1200
!  integer(kind=4), parameter :: nt = 16000
  integer(kind=4):: ntd 

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: a = 0.2
  real(kind=8) :: b = 0.2
  real(kind=8) :: c = 6
  real(kind=8) :: fn(ii,0:nt)=0
  real(kind=8) :: fn_ad(ii,0:nt)=0
  real(kind=8) :: fn_tl(ii,0:nt)=0
  real(kind=8) :: h = 5.0D-4
  real(kind=8) :: sigb = 0.2
  real(kind=8) :: sigm = 2
  real(kind=8) :: sigo = 0.2
  real(kind=8) :: xb(ii)

contains
  subroutine param_constructor_ad
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
    implicit none

!----------------------------------------------
! RESET ADJOINT MODULE VARIABLES
!----------------------------------------------
    fn_ad(:,:) = 0._ikind2

  end subroutine param_constructor_ad
end module     param

module obsdata
  use param
  implicit none
  real(8) :: xobs(ii,nobs)
  real(8) :: xo(ii,0:nt)
  real(8) :: tobs(nobs), t
  real(8) :: x_fg(ii,0:nt)
contains
  subroutine setobs(rank)
    implicit none
    real(8) :: dw(ii*nt)
    real(8) :: dw2(ii)
    integer(4), intent(in) :: rank
    integer(4) :: i, it, iobs

    tobs(1) = 0.4
!    do iobs=1,nobs
! write(0,*)"tobs", iobs, tobs(iobs)
!    enddo
!obs data almost on the attractor
    xb(1)= 2.0659834; xb(2)=-0.2977757; xb(3)= 2.0526298

    call func_dw(h,dw2,ii)  
    do i=1,ii
       x_fg(i,0) = xb(i) + sigb*dw2(i) 
    enddo
!    x_fg(1,1) = -5.90851E+00; x_fg(2,1) = -1.91864E+00; x_fg(3,1) =  -1.11507E-02
    call func_dw(h,dw,ii*nt)  
    do it=0,nt-1
       call func_ross( x_fg(:,it),fn(:,it) )
       do i=1,ii
          x_fg(i,it+1) = x_fg(i,it) + fn(i,it)*h + sigm*dw(i+it*ii)
       enddo
    enddo !firstguess

    xo(:,:) = -999
    do it=0,nt
       do iobs = 1,nobs
          if(tobs(iobs)-it*h>-h/2 .and. tobs(iobs)-it*h<=h/2) then
!          if(abs(tobs(iobs)-it*h)<h/2) then
             call func_dw(1.0d0,dw2,ii)  
             do i=1,ii
                xo(i,it) = x_fg(i,it) + sigo*dw2(i)
                xobs(i,iobs) = xo(i,it) 
             enddo
          endif
       enddo
       if(rank.eq.0) write(11,'(a,10(1x,f14.7))') "x",it*h,x_fg(:,it),xo(:,it)
    enddo
  end subroutine setobs
end module obsdata

program    main
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use mpi
  use param
  use obsdata
  use mtmod
  implicit none

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: x(ii,0:nt)
  real(kind=8) :: xx(ii,0:2*nt)
!#ifdef 1
!  real(kind=8) :: x2(ii,0:2*nt)
!#endif
  integer(kind=4) :: it, itr
!  integer(kind=4) :: ntr  =  1000000
  integer(kind=4) :: ntr  = 500000000
!  integer(kind=4) :: dtr  =    100000
  integer(kind=4) :: dtr  =  10000000
  real(8) :: ll=0
  real(8) :: mean(ii,0:2*nt)=0.0  
  real(8) :: vari(ii,0:2*nt)=0.0  
  real(8), allocatable :: mean_all(:,:), vari_all(:,:)
  real(8) :: Z=0.0  
  real(8) :: Z_all=0.0  
  integer(4) :: err, rank, size

  integer(4), parameter :: mm=200
!  integer(4), parameter :: jj=7
  integer(4), parameter :: jj=9
  real(8), parameter :: xmin(3) = (/0.0, -1.5, -1.0/)
  real(8), parameter :: xmax(3) = (/4.0,  2.5,  3.0/)
  real(8) :: dx=(xmax(1)-xmin(1))/mm
  real(8) :: dens(mm,mm,mm,jj)=0.0
  real(8), allocatable :: dens_all(:,:,:,:)
  real(8), allocatable :: dens_max(:)
  integer(4)::  i_map(ii,jj), j
  integer(4) :: mx, my, mz, i
  real(8) :: dw3(ii)
  real(8) :: dum
!  real(4)    :: maxi(2)
!  real(4), allocatable    :: maxi_all(:)

  call mpi_init(err)
  call MPI_Comm_rank(MPI_COMM_WORLD,rank,err)
  call MPI_Comm_size(MPI_COMM_WORLD,size,err)
  if(rank==0) then
     allocate(dens_all(mm,mm,mm,jj))
     dens_all(:,:,:,:)=0.0d0
     allocate(mean_all(ii,0:2*nt))
     mean_all(:,:)=0.0d0
     allocate(vari_all(ii,0:2*nt))
     vari_all(:,:)=0.0d0
     allocate(dens_max(jj))
     dens_max(:) = 0.0d0
!     allocate(maxi_all(2))
!     maxi_all(:) = 0.0d0
  endif

  call sgrnd(1)

# 190

  call setobs(rank)

!  xx(:,:) = x_fg(:,:)
  call sgrnd(7010+rank)
  ens_loop: do itr=1,ntr
!     write(0,*) itr
     x(:,:) = 0.0d0

     xx(:,:) = 0.0d0

     call func_dw(1.0d0,dw3,ii)  
     do i=1,ii
        x(i,0) = xb(i) + sigb*dw3(i) 
     enddo
!#ifdef 1
!     call fwd( x2,ll )
!#else
     call fwd( x, xx, ll )
!#endif
     call diag
     if(mod(itr,dtr)==0) call diag_out
  enddo ens_loop
  call mpi_finalize(err)
contains
  subroutine diag
!    write(0,*)ll, exp(-ll)
    xx(:,0:nt) =  x(:,0:nt)
    mean(:,:) = mean(:,:) + xx(:,:)     *exp(-ll)
    vari(:,:) = vari(:,:) + xx(:,:)**2  *exp(-ll)
    Z         = Z         + exp(-ll)
!    if(exp(-ll) > maxi(1)) then
!       maxi(1) = exp(-ll)
!       maxi(2) = x(1,nt/2)
!    endif
!histgram
    do j=1,jj
!#ifdef 1
       ntd=nt*2/(jj-1)*(j-1)
       mx=floor((xx(1,ntd)-xmin(1))/dx)+1
       my=floor((xx(2,ntd)-xmin(2))/dx)+1
       mz=floor((xx(3,ntd)-xmin(3))/dx)+1
!#else
!       ntd=nt/(jj-1)*(j-1)
!       mx=floor((x(1,ntd)-xmin(1))/dx)+1
!       my=floor((x(2,ntd)-xmin(2))/dx)+1
!       mz=floor((x(3,ntd)-xmin(3))/dx)+1
!#endif
       if(mx>0.and.mx<=mm .and. my>0.and.my<=mm .and. mz>0.and.mz<=mm) then
          dens(mx,my,mz,j) = dens(mx,my,mz,j)+ exp(-ll)
       endif
    enddo
  end subroutine diag

  subroutine diag_out
    call mpi_reduce(mean(:,:),mean_all(:,:),(2*nt+1)*ii,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD,err)
    call mpi_reduce(vari(:,:),vari_all(:,:),(2*nt+1)*ii,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD,err)
    call mpi_reduce(Z,Z_all,1,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD,err)
    call mpi_reduce(dens(:,:,:,:),dens_all(:,:,:,:),mm*mm*mm*jj,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD,err)
!    call mpi_reduce(maxi(:),maxi_all(:),1,MPI_2REAL,MPI_MAXLOC,0,MPI_COMM_WORLD,err)
    if(rank==0) then
       dens_all(:,:,:,:) = dens_all(:,:,:,:)/Z_all
!map_estimate
       do j=1,jj
          dens_max(j) = 0.0
          do mz=1,mm
             do my=1,mm
                do mx=1,mm
                   if(dens_all(mx,my,mz,j)>dens_max(j)) then
                      dens_max(j)    = dens_all(mx,my,mz,j)
                      i_map(1,j)    = mx
                      i_map(2,j)    = my
                      i_map(3,j)    = mz
                   endif
                enddo
             enddo
          enddo
       enddo
       open(22,file="fort.22")
          do my=1,mm
             do mx=1,mm
                write(22,'(5(1x,f15.8))') xmin(1)+dx*(mx-0.5), xmin(2)+dx*(my-0.5), xmin(3)+dx*(i_map(3,3)-0.5), dens_all(mx,my,i_map(3,3),3)/dx**3
             enddo
             write(22,'(3(1x,f15.8))') !blank line
          enddo
       close(22)
       open(23,file="dens.dat",form="unformatted")
       write(23) dens_all(:,:,:,:)/dx**3
       close(23)
       open(23,file="fort.23")
             do mx=1,mm
                write(23,'(5(1x,f15.8))') xmin(1)+dx*(mx-0.5), xmin(2)+dx*(i_map(2,3)-0.5), xmin(3)+dx*(i_map(3,3)-0.5), dens_all(mx,i_map(2,3),i_map(3,3),3)/dx**3
             enddo
             write(23,'(3(1x,f15.8))') !blank line
       close(23)
       mean_all(:,:) = mean_all(:,:)/Z_all
       vari_all(:,:) = vari_all(:,:)/Z_all-mean_all(:,:)**2
       it=nt/(jj-1)*(3-1)
       write(0,'(i10,11(1x,1pe12.5))') itr, it*h, mean_all(:,it), vari_all(:,it), Z_all,  xmin(1)+dx*(i_map(1,3)-0.5)
       open(12,file="fort.12")
       do it=0,2*nt
          write(12,'(a3,20(1x,1pe12.5))') "Out", it*h, mean_all(:,it), vari_all(:,it)
       enddo
       close(12)
    endif
  end subroutine diag_out
end program    main
!#ifdef 1
!subroutine fwd( xx, ll )
!#else
subroutine fwd( x, xx, ll )
!#endif
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use param
  use obsdata
  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(out) :: ll
!#ifdef 1
!  real(kind=8), intent(inout) :: xx(ii,0:2*nt)
  real(kind=8), intent(out) :: xx(ii,0:2*nt)
!#else
  real(kind=8), intent(inout) :: x(ii,0:nt)
!#endif
  real(kind=8) :: dw4(ii*nt)

!==============================================
! declare local variables
!==============================================
  integer(kind=4) :: i
  integer(kind=4) :: it, iobs

  ll = 0.0
  call func_dw(h,dw4,ii*nt)  
  do it = 0, nt-1
!#ifdef 1
!     call func_ross( xx(:,it),fn(:,it) )
!     do i=1,ii
!     xx(i,it+1) = xx(i,it) + fn(i,it)*h + sigm*dw4(i+it*ii)
!     enddo
!#else
     call func_ross( x(:,it),fn(:,it) )
     do i=1,ii
     x(i,it+1) = x(i,it) + fn(i,it)*h + sigm*dw4(i+it*ii)
     enddo
!#endif
  enddo
  do it = 0, nt
     do iobs = 1, nobs
          if(tobs(iobs)-it*h>-h/2 .and. tobs(iobs)-it*h<=h/2) then
!             write(0,*) "it ",it
           do i = 1, ii
!              ll = ll+(x(i,nt)-xobs(i,1))**2/sigo**2/2
!#ifdef 1
!              ll = ll+(xx(i,it)-xobs(i,iobs))**2/sigo**2/2
!#else
              ll = ll+(x(i,it)-xobs(i,iobs))**2/sigo**2/2
!#endif
           end do
        endif
     end do
  end do

  xx(:,nt) = x(:,nt)
  call func_dw(h,dw4,ii*nt)  
  do it = nt, 2*nt-1
     call func_ross( xx(:,it),fn(:,it-nt) )
     do i=1,ii
     xx(i,it+1) = xx(i,it) + fn(i,it-nt)*h + sigm*dw4(i+(it-nt)*ii)
     enddo
  enddo

end subroutine fwd

subroutine func_ross( x, f )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use param

  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(out) :: f(ii)
  real(kind=8), intent(in) :: x(ii)

  f(1) = (-x(2))-x(3)
  f(2) = x(1)+a*x(2)
  f(3) = b+x(1)*x(3)-c*x(3)
end subroutine func_ross

subroutine func_ross_ad( x, x_ad, f_ad )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use param

  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: ikind1 = 8
  integer, parameter :: ikind3 = 8
  integer, parameter :: ikind4 = 8

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(inout) :: f_ad(ii)
  real(kind=8), intent(in) :: x(ii)
  real(kind=8), intent(inout) :: x_ad(ii)

  x_ad(3) = x_ad(3)+f_ad(3)*(x(1)-c)
  x_ad(1) = x_ad(1)+f_ad(3)*x(3)
  f_ad(3) = 0._ikind1
  x_ad(2) = x_ad(2)+f_ad(2)*a
  x_ad(1) = x_ad(1)+f_ad(2)
  f_ad(2) = 0._ikind3
  x_ad(3) = x_ad(3)-f_ad(1)
  x_ad(2) = x_ad(2)-f_ad(1)
  f_ad(1) = 0._ikind4

end subroutine func_ross_ad


subroutine func_dw(h,dw,mm)  
  use mtmod
  implicit none
  integer(4), intent(in) :: mm
  real(8), intent(in)  :: h
  real(8), intent(out) :: dw(mm) 
  real(8) :: x, y, z
  integer(4) :: i
  do i=1,mm/2
     DO
        x = 2.0 * grnd() - 1.0
        y = 2.0 * grnd() - 1.0
        z = x*x + y*y
        if( z <= 1.0 ) exit
     END DO
     dw(2*i-1) = sqrt(h)*x*sqrt(-2.0d0*log(z)/z)
     dw(2*i  ) = sqrt(h)*y*sqrt(-2.0d0*log(z)/z)
  enddo
  if (mod(mm,2)==1) then
     DO
        x = 2.0 * grnd() - 1.0
        y = 2.0 * grnd() - 1.0
        z = x*x + y*y
        if( z <= 1.0 ) exit
     END DO
     dw(mm) = sqrt(h)*x*sqrt(-2.0d0*log(z)/z)
  endif
end subroutine func_dw

subroutine zero_ad
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use param

  implicit none


!----------------------------------------------
! reset adjoint module variables
!----------------------------------------------
  call param_constructor_ad

end subroutine zero_ad
